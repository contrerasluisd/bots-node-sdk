<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/component/registry.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Conversation.html">ComponentInvocation</a><ul class='methods'><li data-type='method'><a href="Conversation.html#.sdkVersion">sdkVersion</a></li><li data-type='method'><a href="Conversation.html#attachment">attachment</a></li><li data-type='method'><a href="Conversation.html#botId">botId</a></li><li data-type='method'><a href="Conversation.html#channelId">channelId</a></li><li data-type='method'><a href="Conversation.html#channelType">channelType</a></li><li data-type='method'><a href="Conversation.html#error">error</a></li><li data-type='method'><a href="Conversation.html#invalidUserInput">invalidUserInput</a></li><li data-type='method'><a href="Conversation.html#keepTurn">keepTurn</a></li><li data-type='method'><a href="Conversation.html#location">location</a></li><li data-type='method'><a href="Conversation.html#logger">logger</a></li><li data-type='method'><a href="Conversation.html#MessageModel">MessageModel</a></li><li data-type='method'><a href="Conversation.html#messagePayload">messagePayload</a></li><li data-type='method'><a href="Conversation.html#nlpResult">nlpResult</a></li><li data-type='method'><a href="Conversation.html#platformVersion">platformVersion</a></li><li data-type='method'><a href="Conversation.html#postback">postback</a></li><li data-type='method'><a href="Conversation.html#properties">properties</a></li><li data-type='method'><a href="Conversation.html#rawPayload">rawPayload</a></li><li data-type='method'><a href="Conversation.html#releaseTurn">releaseTurn</a></li><li data-type='method'><a href="Conversation.html#reply">reply</a></li><li data-type='method'><a href="Conversation.html#request">request</a></li><li data-type='method'><a href="Conversation.html#sessionId">sessionId</a></li><li data-type='method'><a href="Conversation.html#text">text</a></li><li data-type='method'><a href="Conversation.html#transition">transition</a></li><li data-type='method'><a href="Conversation.html#userId">userId</a></li><li data-type='method'><a href="Conversation.html#variable">variable</a></li></ul></li><li><a href="module-Lib.MessageModel.html">MessageModel</a><ul class='methods'><li data-type='method'><a href="module-Lib.MessageModel.html#.addChannelExtensions">addChannelExtensions</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#.addGlobalActions">addGlobalActions</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#.attachmentConversationMessage">attachmentConversationMessage</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#.callActionObject">callActionObject</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#.cardConversationMessage">cardConversationMessage</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#.cardObject">cardObject</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#.locationActionObject">locationActionObject</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#.locationConversationMessage">locationConversationMessage</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#.postbackActionObject">postbackActionObject</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#.postbackConversationMessage">postbackConversationMessage</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#.rawConversationMessage">rawConversationMessage</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#.shareActionObject">shareActionObject</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#.textConversationMessage">textConversationMessage</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#.urlActionObject">urlActionObject</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#.validateConversationMessage">validateConversationMessage</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#isValid">isValid</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#messagePayload">messagePayload</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#rawPayload">rawPayload</a></li><li data-type='method'><a href="module-Lib.MessageModel.html#validationError">validationError</a></li></ul></li><li><a href="module-Middleware.WebhookClient.html">WebhookClient</a><ul class='methods'><li data-type='method'><a href="module-Middleware.WebhookClient.html#MessageModel">MessageModel</a></li><li data-type='method'><a href="module-Middleware.WebhookClient.html#on">on</a></li><li data-type='method'><a href="module-Middleware.WebhookClient.html#receiver">receiver</a></li><li data-type='method'><a href="module-Middleware.WebhookClient.html#send">send</a></li></ul></li><li><a href="module-Testing.MockConversation.html">MockConversation</a><ul class='methods'><li data-type='method'><a href="module-Testing.MockConversation.html#.any">any</a></li><li data-type='method'><a href="module-Testing.MockConversation.html#.fromRequest">fromRequest</a></li><li data-type='method'><a href="module-Testing.MockConversation.html#getReplies">getReplies</a></li></ul></li><li><a href="NLPResult.html">NLPResult</a><ul class='methods'><li data-type='method'><a href="NLPResult.html#entityMatches">entityMatches</a></li><li data-type='method'><a href="NLPResult.html#intentMatches">intentMatches</a></li><li data-type='method'><a href="NLPResult.html#topIntentMatch">topIntentMatch</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-CLI.html">CLI</a></li><li><a href="module-Config.html">Config</a><ul class='methods'><li data-type='method'><a href="module-Config.html">setLogger</a></li></ul></li><li><a href="module-Lib.html">Lib</a></li><li><a href="module-Middleware.html">Middleware</a><ul class='methods'><li data-type='method'><a href="module-Middleware.html#.customComponent">customComponent</a></li><li data-type='method'><a href="module-Middleware.html#.webhookReceiver">webhookReceiver</a></li></ul></li><li><a href="module-Testing.html">Testing</a><ul class='methods'><li data-type='method'><a href="module-Testing.html#.MockRequest">MockRequest</a></li></ul></li><li><a href="module-Util.html">Util</a></li><li><a href="module-Util_MessageModel.html">Util/MessageModel</a><ul class='methods'><li data-type='method'><a href="module-Util_MessageModel.html#.cardToText">cardToText</a></li><li data-type='method'><a href="module-Util_MessageModel.html#.convertRespToText">convertRespToText</a></li></ul></li><li><a href="module-Util_Text.html">Util/Text</a><ul class='methods'><li data-type='method'><a href="module-Util_Text.html#.approxTextMatch">approxTextMatch</a></li></ul></li><li><a href="module-Util_Webhook.html">Util/Webhook</a><ul class='methods'><li data-type='method'><a href="module-Util_Webhook.html#.bodyParserRawMessageVerify">bodyParserRawMessageVerify</a></li><li data-type='method'><a href="module-Util_Webhook.html#.buildSignatureHeader">buildSignatureHeader</a></li><li data-type='method'><a href="module-Util_Webhook.html#.messageToBot">messageToBot</a></li><li data-type='method'><a href="module-Util_Webhook.html#.messageToBotWithProperties">messageToBotWithProperties</a></li><li data-type='method'><a href="module-Util_Webhook.html#.verifyMessageFormat">verifyMessageFormat</a></li></ul></li></ul><h3>Externals</h3><ul><li><a href="external-ExpressApplication.html">ExpressApplication</a></li><li><a href="external-ExpressRequest.html">ExpressRequest</a></li><li><a href="external-ExpressResponse.html">ExpressResponse</a></li><li><a href="external-ExpressRouter.html">ExpressRouter</a></li></ul><h3>Global</h3><ul><li><a href="global.html#init">init</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">lib/component/registry.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const path = require("path");
const fs = require("fs");
const { CONSTANTS } = require("../../common/constants");
const { CommonProvider } = require("../../common/provider");
const { isType } = require("../../common/definitions");

/**
 * Class for estabilishing a collection of components to be used within middleware.
 * Automatically applied by component middleware configurations
 * @memberof module:Lib
 * @see {@link module:Middleware} for more information
 * @private
 */
class ComponentRegistry {
  /**
   * ComponentRegistry constructor.
   * @param _parent - parent registry for child collection.
   */
  constructor(_parent) {
    this._parent = _parent;
    this._collections = new Map();
    this._components = new Map();
    this._json = {};
    // setup additional iVars.
    this._logger = CommonProvider.getLogger();
  }
  /**
   * Create a registry from a list of component references. The resulting registry
   * is flat and does NOT group components into collections.
   * @param components - array of components, which can be paths, objects, or classes.
   * @param cwd - working directory
   */
  static create(components, cwd = process.cwd()) {
    return new ComponentRegistry(null)
      .__buildFromItems(components, cwd);
  }
  /**
   * Assemble a component registry from the filesystem.
   * Directories within the main component directory will be consumed as independent
   * child component collections.
   * @param parent - parent registry for nested "collections"
   * @param componentDir - relative path to component directory
   * @param cwd - working directory
   */
  static assemble(parent, componentDir = CONSTANTS.DEFAULT_COMPONENT_DIR, cwd = process.cwd()) {
    // verify absolute component dir
    componentDir = fullPath(cwd, componentDir);
    // instantiate and scan the fs
    return new ComponentRegistry(parent)
      .__buildFromFs(componentDir, !parent);
  }
  /**
   * Build a registry with high degree of flexibility in list items.
   * @param list - Array of component references; can be paths, objects, or classes.
   * @param baseDir - Base path reference for resolving string component paths.
   * @private
   */
  __buildFromItems(list, baseDir) {
    const results = [].concat(list).map(item => {
      if (isComponent(item)) {
        return [this.__componentFactory(item)];
      } else if (typeof item === 'object') {
        // resolve from object containing {[key: string]: component}
        return Object.keys(item)
          .map(k => item[k])
          .filter(isComponent)
          .map(ref => this.__componentFactory(ref));
      } else if (typeof item === 'string') {
        // resolve from path, considering each path may contain >=1 components
        return this.__digestPath(fullPath(baseDir, item), false);
      }
    }).filter(item => item &amp;&amp; item.length); // filter empties
    // flatten and register
    [].concat(...results)
      .forEach(component => this.__register(component));
    return this;
  }
  /**
   * Scan directory for valid components
   * @param baseDir - Top level directory for this registry
   * @param withCollections - group subdirectories as collections
   * @return void
   * @private
   */
  __buildFromFs(baseDir, withCollections) {
    const dir = path.resolve(typeof baseDir === 'string' ? baseDir : '');
    if (fs.existsSync(dir)) {
      this.__scanDir(dir, withCollections)
        .forEach(component => this.__register(component));
    } else {
      this._logger.error(`Invalid component directory ${baseDir}`);
    }
    return this;
  }
  /**
   * scan a directory for valid component implementations
   * @param dir - directory to scan for components
   * @param withCollections - group subdirectories as collections
   * @private
   */
  __scanDir(dir, withCollections) {
    const results = fs.readdirSync(dir) // scan directory for components
      .filter(name => !/^\./.test(name) &amp;&amp; ~['', '.js'].indexOf(path.extname(name))) // js and folders
      .map(name => path.join(dir, name)) // absolute path
      .sort(a => {
        return fs.statSync(a).isDirectory() ? 1 : 0;
      })
      .map(file => this.__digestPath(file, withCollections));
    // because __digest returns an array, we need to flatten the final result.
    return [].concat(...results);
  }
  /**
   * resolve (file|dir)path into component instantiations.
   * @param filePath - absolute path to a component resource or directory
   * @param withCollections - consider directories as separate registry collections.
   * @private
   */
  __digestPath(filePath, withCollections) {
    // consider case where manual registry is used and contain files references without extensions
    filePath = fs.existsSync(filePath) ? filePath : `${filePath}.js`;
    const stat = fs.statSync(filePath);
    if (stat.isDirectory() &amp;&amp; withCollections) {
      // create new registry from the child directory
      this._addCollection(filePath);
    } else if (stat.isDirectory()) {
      // scan the directory and flatten
      return this.__scanDir(filePath, false);
    } else if (stat.isFile()) {
      // resolve as classes from the files
      return this.__resolveComponents(filePath)
        .map(c => this.__componentFactory(c));
    }
    return [];
  }
  /**
   * create a child collection of components from a subdirectory
   * @param subdir - component subdirectory absolute path
   * @private
   */
  _addCollection(subdir) {
    this._collections.set(path.basename(subdir), ComponentRegistry.assemble(this, subdir));
  }
  /**
   * resolve Component classes from
   * @param filePath - source file absolute path
   * @private
   */
  __resolveComponents(filePath) {
    try {
      const mod = require(filePath);
      if (isComponent(mod)) {
        // handle direct export case `export = SomeComponentClass`
        return [mod];
      } else {
        // handle case where a single file exports object(s) as keys.
        return Object.keys(mod)
          .map(key => mod[key])
          .filter(isComponent);
      }
    } catch (e) {
      this._logger.error(e);
      throw new Error(`Invalid component path: ${filePath}`);
    }
  }
  /**
   * component instantiation factory.
   * @param mod - component reference (class|object)
   * @private
   */
  __componentFactory(mod) {
    const ctor = makeCtor(mod);
    return new ctor();
  }
  /**
   * register an instantiated component in
   * @param component - instantiated bot component class
   * @private
   */
  __register(component) {
    const meta = component.metadata();
    if (this.isComponent(meta.name)) {
      return this._logger.warn(`Duplicate component found: ${meta.name} while attempting to register ${component['constructor'].name}`);
    } else {
      this._components.set(meta.name, component);
      this._json[meta.name] = component;
    }
  }
  /**
   * merge components from another registry
   * @param registry - Source registry for merge operation.
   * @param recursive - Recursively merge into child collections.
   */
  merge(registry, recursive) {
    if (registry &amp;&amp; registry instanceof ComponentRegistry &amp;&amp; registry.isValid()) {
      registry.getComponents().forEach(component => {
        this.__register(component);
        if (recursive) {
          this._collections.forEach(collection => collection.__register(component));
        }
      });
    }
    return this;
  }
  /**
   * Legacy conversation shell compatability "components" property getter
   * @desc allows components to be resolved by `registry.components`
   */
  get components() {
    return Object.assign({}, this._json);
  }
  /**
   * test if registry is valid.
   * @return boolean.
   */
  isValid() {
    return (this._components.size || this._collections.size) > 0;
  }
  /**
   * list collections in this registry
   */
  getCollectionNames() {
    let keys = [];
    this._collections.forEach((coll, name) => {
      keys.push(name);
    });
    return keys;
  }
  /**
   * get a registry for a specific collection of components.
   * @param collection - (optional) the name of the collection;
   * @return child registry | this.
   */
  getRegistry(collection) {
    return collection ? this._collections.get(collection) : this;
  }
  /**
   * get component map for this registry
   */
  getComponents() {
    return this._components;
  }
  /**
   * get component from map by name
   * @param name - component name
   */
  getComponent(name) {
    return this._components.get(name);
  }
  /**
   * test existence of collection
   * @param name - collection name
   */
  isCollection(name) {
    return this._collections.has(name);
  }
  /**
   * test existence of component
   * @param name - component name
   */
  isComponent(name) {
    return this._components.has(name);
  }
  /**
   * return component metadata as json array
   * @param collection - the collection name, defaults to the parent collection (optional)
   * @return - array of component metadata
   */
  getMetadata(collection) {
    const registry = this.getRegistry(collection);
    let meta = [];
    if (registry) {
      registry.getComponents().forEach(component => {
        // push a copy of the metadata
        meta.push(Object.assign({}, component.metadata()));
      });
    } else {
      this._logger.error(`Invalid registry requested ${collection}`);
    }
    return meta;
  }
}

/**
 * get full path in fs.
 * @param cwd - absolute path
 * @param dirname - a directory or file string
 * @private
 */
function fullPath(cwd, dirname) {
  return ~dirname.indexOf(cwd) ? dirname : path.join(cwd, dirname);
}
/**
 * wrap a raw Object in a constructor function.
 * @desc converts module.exports = {} to a prototyped object
 * @param type - component reference object
 * @private
 */
function makeCtor(type) {
  return (isType(type) &amp;&amp; type) || (function LegacyComponentWrapper() {
    return type;
  });
}
/**
 * test for class decorated with @Component
 * @param ref class or object from exports.
 * @todo create a decorator factory to test annotations against instanceof
 * @private
 */
function isComponent(ref) {
  return (isType(ref) &amp;&amp; ref.prototype &amp;&amp; isType(ref.prototype.metadata) &amp;&amp; isType(ref.prototype.invoke)) || // class usage
    (typeof ref === 'object' &amp;&amp; isType(ref.metadata) &amp;&amp; isType(ref.invoke)); // legacy
}

module.exports = {
  ComponentRegistry,
}</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
